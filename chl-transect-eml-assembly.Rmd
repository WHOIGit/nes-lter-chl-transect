---
title: "NES-LTER Chlorophyll Transect"
author: "Jaxine Wolfe, Kate Morkeski, Stace Beaulieu"
date: "Nov 2019 - Apr 2021"
output: html_document
---

## R Markdown Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)

# define source for functions developed for the EDI packaging workflow
source("edi-utilities.R")

# define R packages to require 
require(here)
require(tidyverse)
require(readxl)
require(lubridate)
require(devtools)
require(EMLassemblyline)
require(EML)
require(maps)
require(xml2)
require(geosphere)
require(httr)

#set path to root of project
here("nes-lter-chl-transect")
```

## Compile Chl Transect Data
```{r}

# define the list of cruises to acquire data from (cruises LTER and JP)
# we will call OOI cruises separately
cruiselist <- c("en608","en617", "en627", "en644", "en649", "ar22", "ar32")
  
# pull from API if compiled cruise data file doesnt exist in directory
if (!file.exists("chl-transect-api.csv")) {

  # compile cruise data from api
  api_chl <- read_from_api(type = "chl", cruises = cruiselist)

  # fix known issues with the data as available from the API
  # EN627 there was no cast 4 per se, rather the btl file 4 for niskins 7-12
  # should be appended to cast 3
  api_chl <- api_chl %>% 
   mutate(
        cast = ifelse(cruise == "EN627" & cast=="4", 
                   yes = 3, 
                   no = api_chl$cast))
  # Not provided by API due to missing value: EN627 cast 17 niskin 8 filter 20 rep b; EN627 cast 26 niskin 7 filter 20 rep b
  
  # write csv file of concatenated cruises
  write.csv(api_chl, 'chl-transect-api.csv', row.names=FALSE)
} else {
  # read in existant data file
  api_chl <- read_csv("chl-transect-api.csv")
}

```

## Compile Menden-Deuer Chl Data

Cruises that use 12-bottle rosettes will have hyphenated casts (done in rapid succession, considered to be paired)

```{r}

# store and read in the Menden-Deuer (SMD) files in the directory
files <- Sys.glob("*SMD*.csv")
cruises <- lapply(files, read_csv)
# compile the data into on dataframe
smd_chl <- do.call(rbind, cruises) %>%
  filter(!is.na(cruise))

# expand SMD data
smd_expanded <- smd_chl %>%
  select(cruise, cast, niskin) %>%
  # expand cast
  mutate(cast_expand = strsplit(cast, "-")) %>%
  unnest(cast_expand) %>%
  # expand niskin
  mutate(niskin_expand = strsplit(niskin, "-")) %>%
  unnest(niskin_expand)

# assign expanded columns to numeric type
smd_expanded$cast_expand <- as.numeric(smd_expanded$cast_expand)
smd_expanded$niskin_expand <- as.numeric(smd_expanded$niskin_expand)

```

## MODIFIED Utility Function: Find Paired Casts

Input: df = data frame; min.time = window of minimum time difference (in mins)

Output: Adds a field to the df indicating the associated paired cast if it exists

Note: this function is modified from the utilities function 
```{r}

find_paired_casts <- function(df, min.time) {
  
  # cruiselist <- unique(df$cruise)
  # # read in ctd data
  # ctd_metadata <- read_from_api(type = "metadata", cruises = cruiselist)
  # ctd_summary <- read_from_api(type = "summary", cruises = cruiselist)
    
  # define column to display paired cast
  df$paired_cast <- NA_character_

  for (j in 1:nrow(df)) {
    # store values for current row
    df_cruise <- df$cruise[j]
    df_cast <- df$cast_expand[j] # the smd cast had to be expanded 
  
    # isolate cast metadata and bottle summary
    cast_metadata <- ctd_metadata %>% filter(cruise == df_cruise & cast == df_cast)
    cast_summary <- ctd_summary %>% filter(cruise == df_cruise & cast == df_cast)
    
    # define the min and max time for the cast 
    df_date_max <- max(cast_summary$date)
    df_date_min <- min(cast_summary$date)
  
    # find the cast before from the bottle summary
    cast_before <- ctd_summary %>% 
      filter(cruise == df_cruise & cast == (df_cast-1))
    # find the cast after from the ctd metadata
    cast_after <- ctd_metadata %>% 
      filter(cruise == df_cruise & cast == (df_cast+1))
  
    # deterine the time difference
    time_before <- min(abs(as.numeric(difftime(df_date_min, cast_before$date, units = "mins"))),
                       na.rm = TRUE)
    time_after <- min(abs(as.numeric(difftime(df_date_max, cast_after$date, units = "mins"))),
                      na.rm = TRUE)
    
    # determine paired casts if they exist
    if (time_after > min.time & time_before > min.time) {
      j <- j + 1
      next
    }
    if (time_before < min.time) {
      # isolate cast metadata to extract station
      before_metadata <- ctd_metadata %>% filter(cruise == df_cruise & cast == (df_cast-1))
      if (isFALSE(cast_metadata$nearest_station == before_metadata$nearest_station)) {
          print(paste0("paired cast found for cruise ", df_cruise, 
                       " and cast ", df_cast, ", but nearest station did not match"))
        j <- j + 1
        next
      } else {
        df$paired_cast[j] <- df_cast - 1
      }
    }
    if (time_after < min.time) {
      if (isFALSE(cast_metadata$nearest_station == cast_after$nearest_station)) {
          print(paste0("paired cast found for cruise ", df_cruise, 
                       " and cast ", df_cast, ", but nearest station did not match"))
        j <- j + 1
        next
      } else {
        df$paired_cast[j] <- df_cast + 1
      }
    }
  }
return(df)
}

```

## Utility Function: Depth Window
Input: Depth
Output: Acceptable depth difference

This is a linear relationship based on our expectations for depth differences in observations. We expect lesser difference at lesser depths, and vice versa.
```{r}

depth_window <- function(x) {
  # Define the relationship between the depth and the depth difference
  y <- (2/29)*x + 2
  return(y)
}

# Example
# depth_window(50.091)
# output: 5.454552
```

## Load CTD Bottle Summary and Metadata from API
```{r}
# compile ctd bottle summary
# pull from API if compiled cruise data file doesnt exist in directory
if (!file.exists("ctd-bottle-summary.csv")) {
  # compile the bottle summary
  ctd_summary <- read_from_api(type = "summary", cruises = cruiselist)
  # write csv file of concatenated cruises
  write.csv(ctd_summary, 'ctd-bottle-summary.csv', row.names=FALSE)
} else {
  # read in existant data file
  ctd_summary <- read_csv("ctd-bottle-summary.csv")
}

# compile ctd metadata
# pull from API if compiled cruise data file doesnt exist in directory
if (!file.exists("ctd-metadata.csv")) {
  # compile the ctd metadata
  ctd_metadata <- read_from_api(type = "metadata", cruises = cruiselist)
  # write csv file of concatenated cruises
  write.csv(ctd_metadata, 'ctd-metadata.csv', row.names=FALSE)
} else {
  # read in existant data file
  ctd_metadata <- read_csv("ctd-metadata.csv")
}
```

## Determining bottle other method

This section:
  • determines depth, lat & lon, and datetime for Menden-Deuer data (merged from bottle summary)
  • determines chl transect bottles associated with SMD bottles based on depth window

```{r}

# merge geospatial and temporal metadata from bottle summary

smd_key <- left_join(smd_expanded, ctd_summary, 
                       by = c("cruise", 
                              "cast_expand" = "cast", 
                              "niskin_expand" = "niskin")) %>%
  distinct() %>%
  # find the average depth, date, lat & lon across cruise-cast-bottle
  group_by(cruise, cast_expand, cast, niskin) %>%
  summarise(depth = mean(depth),
            date = mean(date), 
            latitude = mean(latitude),
            longitude = mean(longitude))

# determine paired casts for the dataset
smd_key <- find_paired_casts(smd_key, min.time = 50)

# create row to populate with bottle other method
smd_key$bottle_other_method <- NA_integer_

# loop through rows
for (i in 1:nrow(smd_key)) {
  # store the cruise, cast, and average depth for current row
  smd_cruise <- smd_key$cruise[i]
  smd_cast <- smd_key$cast_expand[i]
  smd_depth <- smd_key$depth[i]
  
  # subset the chl transect data by cruise
  api_cruise <- api_chl %>%
    select(cruise, cast, niskin, date, latitude, longitude, depth) %>%
    distinct() %>%
    filter(cruise == smd_cruise)

  # Case: the SMD cast is not found in chl transect 
  if (isFALSE(smd_cast %in% api_cruise$cast)) {
    
    # Case: paired cast exists in chl transect
    if (smd_key$paired_cast[i] %in% api_cruise$cast) {
      smd_cast <- smd_key$paired_cast[i]
    } else {
      print(paste0("No associated cast found for cruise ", smd_cruise, 
            ", SMD cast ", smd_cast))
      i <- i + 1
      next
    }
  }
  
  # further subset the chl transect to isolate cruise-cast data
  api_cast <- api_cruise %>% filter(cast == smd_cast)
  
  # find the index of the nearest depth
  ind <- which.min(abs(smd_depth - api_cast$depth))
  
  # Print minimum depth difference if it exceeds 2m
  if (min(abs(smd_depth - api_cast$depth)) > depth_window(smd_depth)) {
    # store min depth window
    depth <- min(abs(smd_depth - api_cast$depth))
    # describe cruise, cast, and depth which exceeds the depth window
    print(paste0("High depth difference of ", depth, " for cruise ", 
                 smd_cruise, ", cast ", smd_key$cast_expand[i], ", average depth: ", smd_depth))
    # do not populate the bottle other method
    i <- i + 1
    next
  }
  # populate field for niskin number associated with other method
  smd_key$bottle_other_method[i] <- api_cast$niskin[ind]
}

```


## Preparing Datasets for Merge

This step populates the fields:
  • bottle_other_method for api_chl
  • date, lat, long, (avg) depth, and bottle_other_method for smd_chl
  • method_contributor to indicate which sample collection and processing methods were used 
  
Additional steps:
  • reorganize the columns
  • merge the api_chl and smd_chl datasets
  • round numerical columns
  • add project_id column (smd = LTER, api = if cruise AR22/32, yes = "JP", no = "LTER")
      - This is to accomodate that the api doesnt yet provide project_id
  
```{r}

## API transect chl
api_chl_final <- smd_key %>% ungroup() %>% 
  select(cruise, cast_expand, niskin, bottle_other_method) %>%
  left_join(api_chl, .,
            by = c("cruise", "cast" = "cast_expand", "niskin" = "bottle_other_method")) %>%
  rename_at("niskin.y", ~"bottle_other_method")

# add method_contributor column based on filter size
api_chl_final <- api_chl_final  %>% 
    mutate(method_contributor  = case_when(filter_size=="<10" ~ "method_Sosik",         
                                           filter_size==">5" ~ "method_Rynearson", 
                                           filter_size==">20" ~ "method_Rynearson", 
                                           filter_size==">0" ~ "method_Sosik")) 

sum(is.na(api_chl_final$method_contributor))
```
## Join API data and Menden-Deuer data

```{r}
# convert data types to enable cbind with smd data
api_chl_final$cast <- as.character(api_chl_final$cast)
api_chl_final$niskin <- as.character(api_chl_final$niskin)

## SMD chl
smd_chl_final <- smd_key %>% ungroup() %>% 
  select(cruise, cast, niskin, depth, date, 
         latitude, longitude, bottle_other_method) %>%
  group_by(cruise, cast, niskin, bottle_other_method) %>%
  # collapse the expanded casts
  summarise(depth = mean(depth),
            date = mean(date), 
            latitude = mean(latitude),
            longitude = mean(longitude)) %>%
  right_join(smd_chl, by = c("cruise", "cast", "niskin"))

# add method_contributor col 
smd_chl_final$method_contributor <- "method_Menden-Deuer" 
#smd_chl_final$filter_prefilter <- paste(smd_chl_final$filter_size, "<200", collapse = " ") 
# hard code the three records with no prefiltering
# cruise en627 cast 30 niskin 1-2-3-4 last 3 samples have no 200um prefiltering 
smd_chl_final <- smd_chl_final   %>%
        mutate(filter_size = paste(filter_size, "<200", sep = "&")) %>%
        mutate(filter_size  = case_when(cruise == "EN627" & ra_blank == "139.66" ~ ">0",         
                                           cruise == "EN627" & ra_blank == "123.66" ~ ">0", 
                                           cruise == "EN627" & ra_blank == "119.66" ~ ">0",
                                           TRUE ~ filter_size) )
  

# important to check for NAs after using case_when
sum(is.na(smd_chl_final$method_contributor))

# convert data types to enable cbind with smd data
smd_chl_final$bottle_other_method <- as.character(smd_chl_final$bottle_other_method)

# define headers for columns in desired order
headers <- c("cruise", "cast", "niskin", "bottle_other_method", "date", "latitude", "longitude", "depth", "method_contributor", "replicate","vol_filtered", "filter_size", "tau_calibration", "fd_calibration", "rb", "ra", "blank", "rb_blank", "ra_blank", "chl", "phaeo")
# reorder columns as necessary
api_chl_final <- api_chl_final[, headers]
smd_chl_final <- smd_chl_final[, headers]

# merge datasets by row
chl_all <- bind_rows(api_chl_final, smd_chl_final)

# eliminate extra columns, set cast type, round numeric columns
chl_all <- chl_all %>% 
  select(-vol_filtered, -tau_calibration, -fd_calibration, -rb, -ra, -blank, -rb_blank, -ra_blank) %>% 
  mutate(cast = as.character(cast)) %>% 
  mutate(latitude = round(latitude, 4)) %>% 
  mutate(longitude = round(longitude, 4)) %>% 
  mutate(depth = round(depth, 3))  %>%
  mutate(chl = round(chl, 3)) %>% 
  mutate(phaeo = round(phaeo, 3)) 

# round nutrient, distance, and depth columns    
#all_cruises[, round_cols] <- round(all_cruises[, round_cols], 3)    
# round lat and lon columns    
#all_cruises[, c("latitude", "longitude")] <- round(all_cruises[, c("latitude", "longitude")], 4)

# row sorting
# define order for filter size and cast columns
size_sort <- c(">0",">5","<10",">10",">20")
cast_sort <- str_sort(unique(chl_all$cast), numeric = TRUE)
# sort by cruise-cast-size
chl_all <- chl_all[with(chl_all, order(cruise, match(cast, cast_sort),
                                    match(filter_size, size_sort))), ]

# add project_id
chl_all$project_id <- ifelse(chl_all$cruise == "AR22" | 
                                     chl_all$cruise == "AR32", 
                                   yes = "JP", no = "LTER")
chl_all$alternate_sample_id <- NA_character_

```

## Read in and join OOI data

```{r}

# read in data
chl_ar24 <- read_csv('ar24.csv')

chl_ar24$bottle_other_method <- NA_character_
chl_ar24 <- chl_ar24 %>%
  mutate(cast = as.character(cast)) %>% 
  rename(alternate_sample_id = filter_id_ooi)

# define headers for columns in desired order
headers_join <- c("cruise", "cast", "niskin", "bottle_other_method", "date", "latitude", "longitude", "depth", "method_contributor", "replicate", "alternate_sample_id", "filter_size",  "chl", "phaeo", "project_id")
# reorder columns as necessary
chl_ar24 <- chl_ar24[, headers_join]
chl_all <- chl_all[, headers_join]

# bind rows
chl_transect <- bind_rows(chl_all, chl_ar24)

# sort by cruise, cast, niskin, filter size
size_sort <- c(">0",">5","<10",">10",">20")
cruise_sort <- str_sort(unique(chl_transect$cruise))
cast_sort <- str_sort(unique(chl_transect$cast))
niskin_sort <- str_sort(unique(chl_transect$niskin), numeric = TRUE)

chl_transect <- chl_transect[with(chl_transect, order(cruise, match(cast, cast_sort), match(niskin, niskin_sort),
                                    match(filter_size, size_sort))), ]
chl_transect <- chl_transect[with(chl_transect, order(cruise, cast)), ]

# write csv file of concatenated cruises
#write.csv(chl_transect, 'nes-lter-chl-transect.csv', row.names=FALSE)
```

## Find Nearest Station and Station Distance

```{r}
chl_dis <- chl_transect

# initialize nearest station and distance columns to NA

chl_dis$nearest_station <- NA_character_
chl_dis$distance <- NA_integer_

# use a standard list of stations L1-L13
# read list csv into stations
stations <- read_csv('NES-LTER_standard_stations_201808.csv')

station_matrix <- matrix(data = c(stations$longitude, stations$latitude), nrow = 14, ncol = 2, byrow = FALSE,
             dimnames = NULL)

# calculate distance per row of the data frame
for (df_row in 1:nrow(chl_dis)) {
  df_lon <- chl_dis$longitude[df_row]
  df_lat <- chl_dis$latitude[df_row]
  # add an if to skip the row if df lon and/or lat is NA
  if (!is.na(df_lon) & !is.na(df_lat)) {
    df_lon_lat <- c(df_lon,df_lat)
    km_from_df <- distHaversine(station_matrix, df_lon_lat, r=6378.137)
    # index the minimum distance
    index <- which.min(km_from_df)
    # use that index to pull the station name and its distance
    nearest_station_list <- stations[index,'station']
    # need to change this from a list to char
    nearest_station <- unname(unlist(nearest_station_list))
    distance <- km_from_df[index]
    # If distance less than 1 km, use base R to add to respective columns in the full data table within the for loop
    if (distance < 2) {
      chl_dis$nearest_station[df_row] <- nearest_station
      chl_dis$distance[df_row] <- distance
    }
  }
}

chl_dis$distance <- round(chl_dis$distance, 2)

```

## QA: Station Distance Outliers

Isolate samples that were taken at a distance greater than 2km from the nearest station

```{r}

st_dist_outliers <- chl_dis %>%
  filter(is.na(distance))

```
## Add the Quality Flag for Data from the Sosik Lab

In the future the API will output the quality_flag column,
but for now we put a csv file into the repo created from the Xls sheet in the RDS 'raw' to API

```{r}

# read in the csv file with quality_flag
# note there are more cruises because ar31, ar34, and ar39
qualities <- read_csv('NESLTERchl_20210409_RDS_quality_flag.csv')
qualities$cast <- as.character(qualities$cast)

# left join to retain the rows in the chl data frame
chl_qual <- left_join(chl_dis, qualities, by = c('cruise','cast','niskin','filter_size','replicate'))

# check that there are no NAs in quality_flag for method_contributor Sosik or Rynearson ie no missing joins
missing_qual <- chl_qual %>%
  filter(method_contributor == "method_Sosik" | method_contributor == "method_Rynearson") %>%
  filter(is.na(quality_flag))
# there is only one missing quality flag, and it actually is missing in the original sheet

# check that there are no values in quality_flag for method_contributor Menden-Deuer ie incorrect join
incorrect_qual <- chl_qual %>%
  filter(method_contributor == "method_Menden-Deuer") %>%
  filter(!is.na(quality_flag))

# I think we can keep the quality flag in the final product but consider using IODE flag
# if we keep quality flag in final product then insert a good quality flag for Menden-Deuer

# maybe add quick check that station in csv qual matches calculated nearest station

# exclude station from csv qual
chl_qual <- select(chl_qual, -station)
 
write.csv(chl_qual, 'nes-lter-chl-transect.csv', row.names=FALSE)

```

## QA: Compare datasets

Compare the average chl for groupings of cruise, cast, bottle, and filter_size.

```{r}

# summarize SMD for comparison
qa_smd <- smd_key %>%
  right_join(smd_chl, by = c("cruise", "cast", "niskin")) %>%
  group_by(cruise, cast_expand, bottle_other_method, paired_cast, filter_size) %>%
  summarise(avg_chl = mean(chl, na.rm = TRUE))

# summarize transect data for comparison
# api_chl_final was formerly transect_chl_final 
qa_transect <- api_chl_final %>%
  group_by(cruise, cast, niskin, filter_size) %>%
  summarise(avg_chl = mean(chl, na.rm = TRUE))

# define fields for logical and numerical comparisons
qa_smd$chl_compare <- FALSE
qa_smd$chl_diff <- NA_integer_

# loop through rows of SMD dataset
for (k in 1:nrow(qa_smd)) {
  # isolate variables from SMD data
  smd_cruise <- qa_smd$cruise[k]
  smd_cast <- qa_smd$cast_expand[k]
  smd_bottle <- qa_smd$bottle_other_method[k]
  smd_filter <- qa_smd$filter_size[k]
  avg_chl_smd <- round(qa_smd$avg_chl[k], 2)
  
  # subset chl transect by cruise
  qa_cruise <- qa_transect %>% filter(cruise == smd_cruise)
           
  # Case: the SMD cast is not found in chl transect 
  if (isFALSE(smd_cast %in% qa_cruise$cast)) {
    
  # Case: paired cast exists in chl transect
    if (qa_smd$paired_cast[k] %in% qa_cruise$cast) {
      smd_cast <- qa_smd$paired_cast[k]
    } else {
      print(paste0("No associated cast found for cruise ", smd_cruise, 
            ", SMD cast ", smd_cast))
      k <- k + 1
      next
    }
  }
  
  # subset chl transect by cast
  qa_cast <- qa_cruise %>%
    filter(cast == smd_cast &
             niskin == smd_bottle &
             filter_size == smd_filter)
  # isolate the mean chl from the chl transect
  avg_chl_trans <- round(qa_cast$avg_chl,2)
  
  # next row if no associated mean chl was found
  if (length(avg_chl_trans) == 0) {
    k <- k + 1
    next
  }
  
  # store difference of averages
  qa_smd$chl_diff[k] <- abs(avg_chl_smd - avg_chl_trans)
  
  # logical mean chl comparison 
  if (avg_chl_smd == avg_chl_trans) {
    qa_smd$chl_compare[k] <- TRUE
  } 
}

```

## QA: Map Sampling Locations

Call the map_locs function from edi-utility.R to map the sampling locations. Perform a visual check.

```{r}

# Map Check
map_locs(df = chl_qual, xvar = "longitude", yvar = "latitude",
         region = "transect", colorvar = "cruise")

```

## EML Assembly

This chunk outputs the final xml file for EDI through the following steps:

Step 1: Populating EML Assembly Line templates with metadata
Step 2: Calculating the geospatial and temporal coverage 
Step 3: Making the XML file 
Step 4: Inserting a custom NES-LTER parent project node 

```{r}

# define input files
metadata <- "chl-transect-info"
edi_filename <- "nes-lter-chl-transect"
pkg_id <- "knb-lter-nes.8.1"

# Make EML Templates 
xlsx_to_template(metadata.path = metadata, 
                 edi.filename = edi_filename, 
                 rights = "CC0")

# Data Coverage
# isolate date and geospatial columns for input
date_col <- as.Date(chl_qual$date)
lat_col <- chl_qual$latitude
lon_col <- chl_qual$longitude
# run function to determine geospatial and temporal coverage
coverage <- data_coverage(dates = date_col, lat = lat_col, lon = lon_col)

# Make EML
make_eml(path = getwd(),
         dataset.title = "Size-fractionated chlorophyll from water column bottle samples collected during NES-LTER Transect cruises, ongoing since 2017.",
         data.table = paste0(edi_filename, ".csv"),
         data.table.description = "Chlorophyll from CTD rosette data cleaned for EDI",
         temporal.coverage = c(coverage$startdate, coverage$enddate),
         geographic.description = "NES-LTER Transect",
         geographic.coordinates = c(coverage$North, coverage$East, coverage$South, coverage$West),
         maintenance.description = "ongoing",
         user.id = "NES",
         user.domain = "LTER",
         package.id = pkg_id)

```

```{r}
# Insert Custom Project Node
project_insert(edi_pkg = pkg_id)
```
## Add semantic annotations

```{r}
#have tried several variations on specifying path but Error: The file specified by the input argument 'eml.in' doesn't exist.

annotate_eml(annotations = "annotations.txt", eml.in = ("/nes-lter-chl-transect/knb-lter-nes.8.1.xml"), eml.out = "knb-lter-nes.8.1.xml")

```